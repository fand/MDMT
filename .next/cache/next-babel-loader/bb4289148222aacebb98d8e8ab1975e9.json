{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault2 = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault2(require(\"@babel/runtime-corejs2/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault2(require(\"@babel/runtime-corejs2/helpers/esm/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault2(require(\"@babel/runtime-corejs2/helpers/esm/createClass\"));\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs2/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\"));\n\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/promise\"));\n\nvar _set = _interopRequireDefault(require(\"@babel/runtime-corejs2/core-js/set\"));\n\nvar _mitt = _interopRequireDefault(require(\"next-server/dist/lib/mitt\"));\n\nvar _unfetch = _interopRequireDefault(require(\"unfetch\"));\n/* global document */\n// smaller version of https://gist.github.com/igrigorik/a02f2359f3bc50ca7a9c\n\n\nfunction supportsPreload(list) {\n  if (!list || !list.supports) {\n    return false;\n  }\n\n  try {\n    return list.supports('preload');\n  } catch (e) {\n    return false;\n  }\n}\n\nvar hasPreload = supportsPreload(document.createElement('link').relList);\n\nvar PageLoader =\n/*#__PURE__*/\nfunction () {\n  function PageLoader(buildId, assetPrefix) {\n    (0, _classCallCheck2[\"default\"])(this, PageLoader);\n    this.buildId = buildId;\n    this.assetPrefix = assetPrefix;\n    this.pageCache = {};\n    this.prefetchCache = new _set[\"default\"]();\n    this.pageRegisterEvents = (0, _mitt[\"default\"])();\n    this.loadingRoutes = {};\n    this.promisedBuildId = _promise[\"default\"].resolve();\n  }\n\n  (0, _createClass2[\"default\"])(PageLoader, [{\n    key: \"normalizeRoute\",\n    value: function normalizeRoute(route) {\n      if (route[0] !== '/') {\n        throw new Error(\"Route name should start with a \\\"/\\\", got \\\"\" + route + \"\\\"\");\n      }\n\n      route = route.replace(/\\/index$/, '/');\n      if (route === '/') return route;\n      return route.replace(/\\/$/, '');\n    }\n  }, {\n    key: \"loadPage\",\n    value: function loadPage(route) {\n      var _this3 = this;\n\n      route = this.normalizeRoute(route);\n      return new _promise[\"default\"](function (resolve, reject) {\n        var fire = function fire(_ref) {\n          var error = _ref.error,\n              page = _ref.page;\n\n          _this3.pageRegisterEvents.off(route, fire);\n\n          delete _this3.loadingRoutes[route];\n\n          if (error) {\n            reject(error);\n          } else {\n            resolve(page);\n          }\n        }; // If there's a cached version of the page, let's use it.\n\n\n        var cachedPage = _this3.pageCache[route];\n\n        if (cachedPage) {\n          var error = cachedPage.error,\n              page = cachedPage.page;\n          error ? reject(error) : resolve(page);\n          return;\n        } // Register a listener to get the page\n\n\n        _this3.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it\n        // rather downloading it again.\n\n\n        if (document.getElementById(\"__NEXT_PAGE__\" + route)) {\n          return;\n        } // Load the script if not asked to load yet.\n\n\n        if (!_this3.loadingRoutes[route]) {\n          _this3.loadScript(route);\n\n          _this3.loadingRoutes[route] = true;\n        }\n      });\n    }\n  }, {\n    key: \"onDynamicBuildId\",\n    value: function onDynamicBuildId() {\n      var _this4 = this;\n\n      this.promisedBuildId = new _promise[\"default\"](function (resolve) {\n        (0, _unfetch[\"default\"])(_this4.assetPrefix + \"/_next/static/HEAD_BUILD_ID\").then(function (res) {\n          if (res.ok) {\n            return res;\n          }\n\n          var err = new Error('Failed to fetch HEAD buildId');\n          err.res = res;\n          throw err;\n        }).then(function (res) {\n          return res.text();\n        }).then(function (buildId) {\n          _this4.buildId = buildId.trim();\n        })[\"catch\"](function () {\n          // When this fails it's not a _huge_ deal, preload wont work and page\n          // navigation will 404, triggering a SSR refresh\n          console.warn('Failed to load BUILD_ID from server. ' + 'The following client-side page transition will likely 404 and cause a SSR.\\n' + 'http://err.sh/zeit/next.js/head-build-id');\n        }).then(resolve, resolve);\n      });\n    }\n  }, {\n    key: \"loadScript\",\n    value: function loadScript(route) {\n      var _this = this;\n\n      return (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee() {\n        var scriptRoute, script, url;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _this.promisedBuildId;\n\n              case 2:\n                route = _this.normalizeRoute(route);\n                scriptRoute = route === '/' ? '/index.js' : route + \".js\";\n                script = document.createElement('script');\n                url = _this.assetPrefix + \"/_next/static/\" + encodeURIComponent(_this.buildId) + \"/pages\" + scriptRoute;\n                script.crossOrigin = process.crossOrigin;\n                script.src = url;\n\n                script.onerror = function () {\n                  var error = new Error(\"Error loading script \" + url);\n                  error.code = 'PAGE_LOAD_ERROR';\n\n                  _this.pageRegisterEvents.emit(route, {\n                    error: error\n                  });\n                };\n\n                document.body.appendChild(script);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    } // This method if called by the route code.\n\n  }, {\n    key: \"registerPage\",\n    value: function registerPage(route, regFn) {\n      var _this5 = this;\n\n      var register = function register() {\n        try {\n          var _regFn = regFn(),\n              error = _regFn.error,\n              page = _regFn.page;\n\n          _this5.pageCache[route] = {\n            error: error,\n            page: page\n          };\n\n          _this5.pageRegisterEvents.emit(route, {\n            error: error,\n            page: page\n          });\n        } catch (error) {\n          _this5.pageCache[route] = {\n            error: error\n          };\n\n          _this5.pageRegisterEvents.emit(route, {\n            error: error\n          });\n        }\n      };\n\n      if (process.env.NODE_ENV !== 'production') {\n        // Wait for webpack to become idle if it's not.\n        // More info: https://github.com/zeit/next.js/pull/1511\n        if (module.hot && module.hot.status() !== 'idle') {\n          console.log(\"Waiting for webpack to become \\\"idle\\\" to initialize the page: \\\"\" + route + \"\\\"\");\n\n          var check = function check(status) {\n            if (status === 'idle') {\n              module.hot.removeStatusHandler(check);\n              register();\n            }\n          };\n\n          module.hot.status(check);\n          return;\n        }\n      }\n\n      register();\n    }\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(route) {\n      var _this2 = this;\n\n      return (0, _asyncToGenerator2[\"default\"])(\n      /*#__PURE__*/\n      _regenerator[\"default\"].mark(function _callee2() {\n        var scriptRoute, link;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                route = _this2.normalizeRoute(route);\n                scriptRoute = (route === '/' ? '/index' : route) + \".js\";\n\n                if (!(_this2.prefetchCache.has(scriptRoute) || document.getElementById(\"__NEXT_PAGE__\" + route))) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 4:\n                _this2.prefetchCache.add(scriptRoute); // Inspired by quicklink, license: https://github.com/GoogleChromeLabs/quicklink/blob/master/LICENSE\n                // Don't prefetch if the user is on 2G / Don't prefetch if Save-Data is enabled\n\n\n                if (!('connection' in navigator)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                if (!((navigator.connection.effectiveType || '').indexOf('2g') !== -1 || navigator.connection.saveData)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 8:\n                if (!hasPreload) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                _context2.next = 11;\n                return _this2.promisedBuildId;\n\n              case 11:\n                link = document.createElement('link');\n                link.rel = 'preload';\n                link.crossOrigin = process.crossOrigin;\n                link.href = _this2.assetPrefix + \"/_next/static/\" + encodeURIComponent(_this2.buildId) + \"/pages\" + scriptRoute;\n                link.as = 'script';\n                document.head.appendChild(link);\n                return _context2.abrupt(\"return\");\n\n              case 18:\n                if (!(document.readyState === 'complete')) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", _this2.loadPage(route)[\"catch\"](function () {}));\n\n              case 22:\n                return _context2.abrupt(\"return\", new _promise[\"default\"](function (resolve) {\n                  window.addEventListener('load', function () {\n                    _this2.loadPage(route).then(function () {\n                      return resolve();\n                    }, function () {\n                      return resolve();\n                    });\n                  });\n                }));\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache(route) {\n      route = this.normalizeRoute(route);\n      delete this.pageCache[route];\n      delete this.loadingRoutes[route];\n      var script = document.getElementById(\"__NEXT_PAGE__\" + route);\n\n      if (script) {\n        script.parentNode.removeChild(script);\n      }\n    }\n  }]);\n  return PageLoader;\n}();\n\nexports[\"default\"] = PageLoader;","map":null,"metadata":{},"sourceType":"script"}